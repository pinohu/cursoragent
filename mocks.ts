/**
 * Mock implementation for testing Cursor Composer Automation
 * 
 * This file provides mock implementations of components that interact with Cursor
 * to allow testing without actual Cursor installation
 */

import { EventEmitter } from 'events';
import * as fs from 'fs-extra';
import * as path from 'path';
import * as winston from 'winston';
import { AutomationStatus } from '../src/core/types';

/**
 * Mock Cursor Controller for testing
 */
export class MockCursorController extends EventEmitter {
  private logger: winston.Logger;
  private workingDirectory: string;
  private isRunning: boolean = false;

  constructor(logger: winston.Logger, cursorPath: string, workingDirectory: string) {
    super();
    this.logger = logger;
    this.workingDirectory = workingDirectory;
    
    // Ensure working directory exists
    if (!fs.existsSync(this.workingDirectory)) {
      fs.mkdirSync(this.workingDirectory, { recursive: true });
    }
  }

  /**
   * Mock launching Cursor
   */
  async launchCursor(): Promise<void> {
    this.logger.info('[MOCK] Launching Cursor application');
    await new Promise(resolve => setTimeout(resolve, 1000));
    this.isRunning = true;
    this.logger.info('[MOCK] Cursor application launched successfully');
  }
  
  /**
   * Mock closing Cursor
   */
  async closeCursor(): Promise<void> {
    this.logger.info('[MOCK] Closing Cursor application');
    await new Promise(resolve => setTimeout(resolve, 500));
    this.isRunning = false;
    this.logger.info('[MOCK] Cursor application closed successfully');
  }
  
  /**
   * Mock activating Composer
   */
  async activateComposer(): Promise<void> {
    this.logger.info('[MOCK] Activating Cursor Composer in Agent mode');
    await new Promise(resolve => setTimeout(resolve, 800));
    this.logger.info('[MOCK] Cursor Composer activated successfully');
  }
  
  /**
   * Mock inputting prompt
   */
  async inputPrompt(prompt: string): Promise<void> {
    this.logger.info('[MOCK] Inputting prompt to Cursor Composer');
    
    // Save prompt to file for verification
    const promptFile = path.join(this.workingDirectory, 'mock_prompt.txt');
    fs.writeFileSync(promptFile, prompt);
    
    await new Promise(resolve => setTimeout(resolve, 1200));
    this.logger.info('[MOCK] Prompt input to Cursor Composer successfully');
    
    // Simulate Composer generating files
    this.simulateFileGeneration();
  }
  
  /**
   * Mock checking completion
   */
  async checkCompletion(): Promise<boolean> {
    this.logger.info('[MOCK] Checking Composer completion status');
    await new Promise(resolve => setTimeout(resolve, 300));
    return true;
  }
  
  /**
   * Mock installing cursor-tools
   */
  async installCursorTools(): Promise<void> {
    this.logger.info('[MOCK] Installing cursor-tools CLI');
    await new Promise(resolve => setTimeout(resolve, 1500));
    this.logger.info('[MOCK] cursor-tools CLI installed successfully');
  }
  
  /**
   * Mock configuring cursor-tools
   */
  async configureCursorTools(): Promise<void> {
    this.logger.info('[MOCK] Configuring cursor-tools');
    await new Promise(resolve => setTimeout(resolve, 800));
    this.logger.info('[MOCK] cursor-tools configured successfully');
  }
  
  /**
   * Simulate Composer generating files
   */
  private async simulateFileGeneration(): Promise<void> {
    this.logger.info('[MOCK] Simulating file generation by Composer');
    
    // Create some mock files
    const files = [
      { path: 'index.html', content: '<html><head><title>Generated App</title></head><body><h1>Generated App</h1><p>This is a mock generated app.</p></body></html>' },
      { path: 'styles.css', content: 'body { font-family: Arial, sans-serif; margin: 0; padding: 20px; }' },
      { path: 'script.js', content: 'console.log("Generated app loaded");' },
      { path: 'package.json', content: '{\n  "name": "generated-app",\n  "version": "1.0.0",\n  "description": "Generated by Cursor Composer",\n  "main": "index.js",\n  "scripts": {\n    "start": "node index.js",\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "author": "",\n  "license": "MIT"\n}' },
      { path: 'README.md', content: '# Generated App\n\nThis app was generated by Cursor Composer Automation.\n\n## Features\n\n- Feature 1\n- Feature 2\n- Feature 3\n\n## Installation\n\n```\nnpm install\n```\n\n## Usage\n\n```\nnpm start\n```\n' }
    ];
    
    // Create src directory
    const srcDir = path.join(this.workingDirectory, 'src');
    fs.ensureDirSync(srcDir);
    
    // Create files with delays to simulate real-time generation
    for (const file of files) {
      await new Promise(resolve => setTimeout(resolve, 500));
      
      const filePath = path.join(this.workingDirectory, file.path);
      fs.writeFileSync(filePath, file.content);
      this.logger.info(`[MOCK] Generated file: ${file.path}`);
    }
    
    // Create a src file
    const indexJs = path.join(srcDir, 'index.js');
    fs.writeFileSync(indexJs, 'console.log("Hello from generated app");\n');
    this.logger.info('[MOCK] Generated file: src/index.js');
    
    // Create completion indicator
    const completionFile = path.join(this.workingDirectory, '.composer_completed');
    fs.writeFileSync(completionFile, new Date().toISOString());
    this.logger.info('[MOCK] Composer completed file generation');
  }
}

/**
 * Mock Deployment Manager for testing
 */
export class MockDeploymentManager extends EventEmitter {
  private logger: winston.Logger;

  constructor(logger: winston.Logger) {
    super();
    this.logger = logger;
  }

  /**
   * Mock deploying application
   */
  async deployApplication(projectDir: string): Promise<Record<string, string>> {
    this.logger.info(`[MOCK] Deploying application from ${projectDir}`);
    
    // Simulate deployment process
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    // Return mock deployment URLs
    return {
      'vercel': 'https://mock-app-vercel.vercel.app',
      'netlify': 'https://mock-app-netlify.netlify.app',
      'aws': 'https://d123456abcdef.cloudfront.net',
      'custom': 'https://example.com/mock-app'
    };
  }
}

/**
 * Mock Orchestrator for testing
 */
export class MockOrchestrator extends EventEmitter {
  private logger: winston.Logger;
  private status: AutomationStatus = AutomationStatus.IDLE;

  constructor(logger: winston.Logger) {
    super();
    this.logger = logger;
  }

  /**
   * Mock start automation process
   */
  async start(idea: any): Promise<any> {
    this.logger.info('[MOCK] Starting automation process');
    
    // Update status and emit events
    this.updateStatus(AutomationStatus.INITIALIZING, 'Initializing automation process');
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    this.updateStatus(AutomationStatus.PROCESSING_IDEA, 'Processing idea input');
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    this.updateStatus(AutomationStatus.LAUNCHING_CURSOR, 'Launching Cursor application');
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    this.updateStatus(AutomationStatus.INTERACTING_WITH_COMPOSER, 'Interacting with Cursor Composer');
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    this.updateStatus(AutomationStatus.MONITORING_PROGRESS, 'Monitoring Composer progress');
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    this.updateStatus(AutomationStatus.TESTING, 'Testing generated application');
    await new Promise(resolve => setTimeout(resolve, 2000));
    
    this.updateStatus(AutomationStatus.DEPLOYING, 'Deploying application');
    await new Promise(resolve => setTimeout(resolve, 3000));
    
    this.updateStatus(AutomationStatus.COMPLETED, 'Automation process completed successfully');
    
    // Return mock result
    return {
      status: AutomationStatus.COMPLETED,
      projectPath: '/mock/path/to/project',
      deploymentUrls: {
        'vercel': 'https://mock-app-vercel.vercel.app'
      },
      logs: ['Log entry 1', 'Log entry 2', 'Log entry 3'],
      duration: 17500
    };
  }
  
  /**
   * Update status and emit events
   */
  private updateStatus(status: AutomationStatus, message: string): void {
    this.status = status;
    this.logger.info(`[MOCK] Status: ${status} - ${message}`);
    
    this.emit('status_changed', status);
    this.emit('progress_update', {
      status,
      message,
      percentage: this.calculateProgress(status),
      timestamp: Date.now()
    });
  }
  
  /**
   * Calculate progress percentage
   */
  private calculateProgress(status: AutomationStatus): number {
    const statusProgressMap: Record<AutomationStatus, number> = {
      [AutomationStatus.IDLE]: 0,
      [AutomationStatus.INITIALIZING]: 5,
      [AutomationStatus.PROCESSING_IDEA]: 10,
      [AutomationStatus.LAUNCHING_CURSOR]: 20,
      [AutomationStatus.INTERACTING_WITH_COMPOSER]: 30,
      [AutomationStatus.MONITORING_PROGRESS]: 50,
      [AutomationStatus.TESTING]: 70,
      [AutomationStatus.DEPLOYING]: 85,
      [AutomationStatus.COMPLETED]: 100,
      [AutomationStatus.FAILED]: 100
    };
    
    return statusProgressMap[status] || 0;
  }
}
